# AIS Project — система оптимизации складских запасов

Учебный проект по дисциплине **«Автоматизированные информационные системы»**.

Это веб-приложение, в котором пользователь:

- регистрируется и входит в систему;
- загружает CSV с данными о товарах и спросе;
- запускает оптимизацию запасов по математической модели;
- получает и скачивает отчёты с оптимальными размерами заказов;
- управляет своими файлами и отчётами через веб-интерфейс.

---

## Функциональность

- **Аутентификация и личный кабинет**
  - Регистрация и вход по логину/паролю.
  - После входа пользователь видит только свои файлы данных и отчёты.

- **Работа с файлами**
  - Загрузка CSV с данными.
  - Проверка расширения и размера файла.
  - Удаление файла с подтверждением: вместе с файлом удаляются все связанные с ним отчёты.

- **Генерация отчётов**
  - Для каждого загруженного файла можно открыть модальное окно и запустить оптимизацию с заданным ограничением на максимальный объём склада.
  - В модальном окне показывается список отчётов по этому файлу (дата, ограничение объёма, итоговая стоимость) с кнопками «Скачать» и «Удалить».

- **Документация API**
  - REST-эндпоинты описаны в стиле Swagger/Flasgger, есть веб документация.

- **Нагрузочное тестирование**
  - Отдельный `locustfile.py` со сценариями стресс-тестирования: просмотр HTML-страниц, массовая загрузка файлов и создание отчётов.

---

## Архитектура и структура проекта

```text
ais_project/
  app.py              # создание Flask-приложения, конфиг, подключение БД, Swagger
  routes.py           # view-функции, REST-эндпоинты, логика файлов и отчётов
  optim.py            # математическая модель оптимизации запасов
  locustfile.py       # сценарии нагрузочного тестирования Locust
  my_data.csv         # пример входных данных
  requirements.txt    # зависимости Python

  database/
    __init__.py       # инициализация SQLAlchemy
    models.py         # модели User, DataFile, OptimizationReport

  instance/
    project_db.sqlite # рабочая БД (если используется SQLite)
    files/            # загруженные CSV
    reports/          # сгенерированные отчёты

  templates/
    index.html        # главная страница: загрузка файлов, список отчётов
    login.html        # форма входа
    register.html     # регистрация пользователя
    about.html        # краткое описание проекта
    team.html         # информация о команде

  static/
    css/              # стили
    js/
      file_ops.js     # загрузка файлов, удаление файлов и отчётов, скачивание отчётов
      modal.js        # модальное окно генерации отчётов и их список
      jaba.js         # визуальные эффекты на странице команды
    images/           # картинки для шаблонов
```

`app.py` создаёт экземпляр **Flask**, настраивает подключение к **БД** (через `SQLALCHEMY_DATABASE_URI`), папки для загрузки файлов и подключает **Swagger**.  
`database/models.py` определяет три основные сущности: пользователя, загруженный файл и отчёт оптимизации, связанные внешними ключами.  
`routes.py` реализует **HTML**-страницы и **JSON-API**: загрузка/удаление файлов, генерация отчётов, скачивание, работа сессий.  
`optim.py` инкапсулирует всю **математику** по расчёту оптимальных заказов. 

---

## Оптимизация запасов — математическая модель
Модуль оптимизации повторяет постановку из статьи  
**Samir Saci — «Procurement Process Optimization with Python»**.

Идея такая:

- Есть набор товарных позиций (SKU), для каждой известны:
  - годовой спрос;
  - закупочная цена;
  - параметры транспортировки (фиксированная стоимость рейса и переменные затраты на коробку);
  - вклад позиции в использование складского пространства.
- Нужно решить, **как часто** пополнять запас каждой позиции (сколько поставок в год). Из частоты пополнений автоматически получается размер одной поставки и средний уровень запаса.
- В целевую функцию входят три типа годовых затрат:
  1. транспортные расходы (рейсы + коробки);
  2. стоимость замороженного в запасах капитала (процент от стоимости среднего запаса);
  3. плата за склад, зависящая от общего занятого объёма.
- Наложены ограничения:
  - суммарный средний объём запаса по всем SKU не превышает заданную вместимость склада;
  - частота пополнения для каждой позиции лежит в разумных пределах (не слишком часто и не слишком редко).

Это даёт задачу нелинейной минимизации: нужно подобрать частоты пополнений так, чтобы **общие годовые затраты были минимальны**, при этом склад не переполнен. Решение находится численным методом; в отчёт попадают оптимальные значения для каждой позиции и итоговая стоимость.

---

## Фронтенд и JavaScript

Фронтенд построен на Jinja2-шаблонах и отдельных JS-скриптах.

### Главная страница (index.html)

- Форма загрузки файла.
- Таблица загруженных файлов с кнопками:
  - «Создать отчёт» — открывает модальное окно;
  - «Удалить» — показывает подтверждение и удаляет файл вместе с его отчётами.

Скрипт `static/js/file_ops.js`:
- перехватывает отправку формы загрузки;
- отправляет файл через `fetch('/upload_data')`;
- блокирует кнопку на время запроса;
- после завершения перезагружает страницу или обновляет список файлов;
- умеет скачивать отчёты и вызывать удаление файлов/отчётов.

### Модальное окно отчётов

Скрипт `static/js/modal.js`:

- открывает модалку для конкретного файла, подставляет `file_id` и имя файла;
- запрашивает список отчётов `/get_reports` и строит таблицу в модальном окне;
- отправляет запрос `/generate_report` с выбранным ограничением объёма;
- обновляет список отчётов без перезагрузки всей страницы.

### Страница «Команда»

Скрипт `static/js/jaba.js`:

- вешает обработчики на аватарки участников;
- при клике меняет изображение между двумя вариантами (реальные люди/олицетворяющие их жабки)
- даёт «игровую» анимацию интерфейсу.

---

## Запуск проекта

### 1. Клонирование репозитория
```bash
git clone https://github.com/DoggerHou/ais_project.git
cd ais_project
```

### 2. Виртуальное окружение и зависимости
```bash
python -m venv .venv

# Windows:
.venv\Scripts\activate
# Linux/macOS:
# source .venv/bin/activate

pip install -r requirements.txt
```
### 3. Настройка БД
В app.py задана строка подключения:

```app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://user:password@localhost:3306/db_name'```
Перед запуском:  
1. Создайте БД в MySQL / MariaDB.  
2. Обновите логин, пароль и имя БД в URI.  
3. При первом запуске приложение создаст таблицы через SQLAlchemy.

При желании можно использовать SQLite, заменив URI, например, на:  
```app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///instance/project_db.sqlite'```


### 4. Запуск приложения
```python app.py```  

По умолчанию сервер доступен по адресу:  
`http://127.0.0.1:5000/`

---

## Нагрузочное тестирование

Нагрузочное тестирование проводилось в три этапа: **на нагрузку**, **на объём** и **стресс-тест**. Цель — понять, сколько запросов и пользователей выдерживает приложение, где узкие места и что нужно улучшать.

### Тестовый стенд и общая методика

- Тестируемое приложение: это веб-сервис оптимизации запасов (Flask + БД).
- Тесты выполнялись из Locust, метрики сервера смотрели через `htop` и `atop`.
- Для каждого теста фиксировались:
  - сценарий запросов;
  - число эмулируемых пользователей и скорость их появления;
  - поведение CPU / диска / времени ответа.

### Нагрузочный тест (GET-запросы)

**Сценарий:**

- GET на страницу «О команде» (`/team`).
- GET для получения списка отчётов по выбранному файлу. 

Число пользователей и частота запросов постепенно увеличивали, следя, чтобы загрузка CPU не выходила за ~60%.  

**Результаты:**

- Сервер устойчиво обрабатывает около **400 запросов в секунду** такого типа без заметной деградации.
- На графике из Locust видно несколько пиков времени ответа в моменты резких всплесков нагрузки, но затем значения стабилизируются.
- Ошибок (5xx/4xx из-за перегрузки) зафиксировано не было.

<img width="839" height="664" alt="image" src="https://github.com/user-attachments/assets/2c733b8d-b1ce-493f-aae0-b054569eff7b" />


### Объёмное тестирование (массовая загрузка файлов)

**Сценарий:**

- POST-запрос, который одновременно:
  - загружает файл в хранилище,
  - добавляет информацию об этом файле в БД.

Цель — понять, при каком количестве одновременных пользователей и загрузок сервер начинает «сыпаться».

**Результаты:**

- Конфигурация около **1500 пользователей** с частой отправкой файлов (до ~250 файлов в секунду суммарно) оказалась ещё рабочей: время ответа приемлемое, ошибок мало.
- При росте до **3000 пользователей** время ответа резко увеличилось, появились ошибки загрузки.
- `htop` и `atop` показали, что главным узким местом в этом сценарии становится **процессор**, а не диск.

<img width="715" height="514" alt="image" src="https://github.com/user-attachments/assets/d0787701-6f4d-4abc-9b80-0798e79be70c" />

<img width="894" height="496" alt="image" src="https://github.com/user-attachments/assets/7c573c2d-5ec9-420a-a1a0-c1dd7b5b3b4b" />


### Стресс-тест (генерация отчётов)

**Сценарий:**

- Повторяющиеся запросы на генерацию отчётов (оптимизация запасов).  
  Это самый тяжёлый запрос: он запускает численный алгоритм оптимизации, который работает десятки итераций и активно грузит CPU.

**Наблюдения:**

- Один запрос на генерацию отчёта занимает порядка **20 секунд** и полностью загружает одно физическое ядро процессора. 
- Сервер без ошибок выдерживает примерно **2 последовательных пользователя**, которые отправляют запросы один за другим.  
  При попытке принять больше запросов задержки сильно растут.
- При этом простые GET-запросы к сайту продолжают обслуживаться, но уже с заметной задержкой.
- Главное узкое место — **CPU**.

**Выводы и возможные улучшения:**

- Для серьёзной боевой нагрузки нужен:
  - балансировщик, который будет ставить тяжёлые запросы в очередь;
  - несколько воркеров / процессов на разных ядрах;
  - либо вынос модуля оптимизации в отдельный сервис.


<img width="941" height="685" alt="image" src="https://github.com/user-attachments/assets/9db04ade-e899-433d-93da-7cfd43d22006" />

<img width="941" height="201" alt="image" src="https://github.com/user-attachments/assets/71383809-2283-4e3c-9bf1-061ecdd22e48" />


В сумме эти три сценария дали картину: приложение хорошо держит массовые лёгкие запросы и объёмные загрузки до определённого предела, а настоящим bottleneck является именно тяжёлая математика в генерации отчётов, которую имеет смысл масштабировать отдельно.

---

## Технологический стек

- **Backend:** Python 3, Flask, Flask-SQLAlchemy, Flasgger (Swagger), Werkzeug.
- **База данных:** MySQL / MariaDB (возможен SQLite).
- **Математика:** pandas, scipy.optimize для решения задачи минимизации.
- **Frontend:** Jinja2, HTML5, CSS3, JavaScript.
- **Нагрузка:** Locust (HttpUser-сценарии для HTML и API).

---

## Скриншоты

### Страница "О нас"
<img width="941" height="458" alt="image" src="https://github.com/user-attachments/assets/142fbe15-ad6b-4baa-8fc6-c3d09bcb6ba5" />

### Модальное окно загруженного файла
<img width="851" height="414" alt="image" src="https://github.com/user-attachments/assets/008ed663-1fac-449a-91ac-8421ba202ede" />

