# AIS Project — система оптимизации складских запасов

Учебный проект по дисциплине **«Автоматизированные информационные системы»**.

Это веб-приложение, в котором пользователь:

- регистрируется и входит в систему;
- загружает CSV с данными о товарах и спросе;
- запускает оптимизацию запасов по математической модели;
- получает и скачивает отчёты с оптимальными размерами заказов;
- управляет своими файлами и отчётами через веб-интерфейс.

---

## Функциональность

- **Аутентификация и личный кабинет**
  - Регистрация и вход по логину/паролю.
  - После входа пользователь видит только свои файлы данных и отчёты.

- **Работа с файлами**
  - Загрузка CSV с данными.
  - Проверка расширения и размера файла.
  - Удаление файла с подтверждением: вместе с файлом удаляются все связанные с ним отчёты.

- **Генерация отчётов**
  - Для каждого загруженного файла можно открыть модальное окно и запустить оптимизацию с заданным ограничением на максимальный объём склада.
  - В модальном окне показывается список отчётов по этому файлу (дата, ограничение объёма, итоговая стоимость) с кнопками «Скачать» и «Удалить».

- **Документация API**
  - REST-эндпоинты описаны в стиле Swagger/Flasgger, есть веб документация.

- **Нагрузочное тестирование**
  - Отдельный `locustfile.py` со сценариями стресс-тестирования: просмотр HTML-страниц, массовая загрузка файлов и создание отчётов.

---

## Архитектура и структура проекта

```text
ais_project/
  app.py              # создание Flask-приложения, конфиг, подключение БД, Swagger
  routes.py           # view-функции, REST-эндпоинты, логика файлов и отчётов
  optim.py            # математическая модель оптимизации запасов
  locustfile.py       # сценарии нагрузочного тестирования Locust
  my_data.csv         # пример входных данных
  requirements.txt    # зависимости Python

  database/
    __init__.py       # инициализация SQLAlchemy
    models.py         # модели User, DataFile, OptimizationReport

  instance/
    project_db.sqlite # рабочая БД (если используется SQLite)
    files/            # загруженные CSV
    reports/          # сгенерированные отчёты

  templates/
    index.html        # главная страница: загрузка файлов, список отчётов
    login.html        # форма входа
    register.html     # регистрация пользователя
    about.html        # краткое описание проекта
    team.html         # информация о команде

  static/
    css/              # стили
    js/
      file_ops.js     # загрузка файлов, удаление файлов и отчётов, скачивание отчётов
      modal.js        # модальное окно генерации отчётов и их список
      jaba.js         # визуальные эффекты на странице команды
    images/           # картинки для шаблонов
```

`app.py` создаёт экземпляр **Flask**, настраивает подключение к **БД** (через `SQLALCHEMY_DATABASE_URI`), папки для загрузки файлов и подключает **Swagger**.  
`database/models.py` определяет три основные сущности: пользователя, загруженный файл и отчёт оптимизации, связанные внешними ключами.  
`routes.py` реализует **HTML**-страницы и **JSON-API**: загрузка/удаление файлов, генерация отчётов, скачивание, работа сессий.  
`optim.py` инкапсулирует всю **математику** по расчёту оптимальных заказов. 

---

### Оптимизация запасов (математика)

## Оптимизация запасов — математическая модель
Модуль оптимизации повторяет постановку из статьи  
**Samir Saci — «Procurement Process Optimization with Python»**.

Идея такая:

- Есть набор товарных позиций (SKU), для каждой известны:
  - годовой спрос;
  - закупочная цена;
  - параметры транспортировки (фиксированная стоимость рейса и переменные затраты на коробку);
  - вклад позиции в использование складского пространства.
- Нужно решить, **как часто** пополнять запас каждой позиции (сколько поставок в год). Из частоты пополнений автоматически получается размер одной поставки и средний уровень запаса.
- В целевую функцию входят три типа годовых затрат:
  1. транспортные расходы (рейсы + коробки);
  2. стоимость замороженного в запасах капитала (процент от стоимости среднего запаса);
  3. плата за склад, зависящая от общего занятого объёма.
- Наложены ограничения:
  - суммарный средний объём запаса по всем SKU не превышает заданную вместимость склада;
  - частота пополнения для каждой позиции лежит в разумных пределах (не слишком часто и не слишком редко).

Это даёт задачу нелинейной минимизации: нужно подобрать частоты пополнений так, чтобы **общие годовые затраты были минимальны**, при этом склад не переполнен. Решение находится численным методом; в отчёт попадают оптимальные значения для каждой позиции и итоговая стоимость.

---

## Фронтенд и JavaScript

Фронтенд построен на Jinja2-шаблонах и отдельных JS-скриптах.

### Главная страница (index.html)

- Форма загрузки файла.
- Таблица загруженных файлов с кнопками:
  - «Создать отчёт» — открывает модальное окно;
  - «Удалить» — показывает подтверждение и удаляет файл вместе с его отчётами.

Скрипт `static/js/file_ops.js`:
- перехватывает отправку формы загрузки;
- отправляет файл через `fetch('/upload_data')`;
- блокирует кнопку на время запроса;
- после завершения перезагружает страницу или обновляет список файлов;
- умеет скачивать отчёты и вызывать удаление файлов/отчётов.

### Модальное окно отчётов

Скрипт `static/js/modal.js`:

- открывает модалку для конкретного файла, подставляет `file_id` и имя файла;
- запрашивает список отчётов `/get_reports` и строит таблицу в модальном окне;
- отправляет запрос `/generate_report` с выбранным ограничением объёма;
- обновляет список отчётов без перезагрузки всей страницы.

### Страница «Команда»

Скрипт `static/js/jaba.js`:

- вешает обработчики на аватарки участников;
- при клике меняет изображение между двумя вариантами (через атрибуты `data-image-1` и `data-image-2`);
- даёт небольшую «игровую» анимацию интерфейсу.

---

## Технологический стек

- **Backend:** Python 3, Flask, Flask-SQLAlchemy, Flasgger (Swagger), Werkzeug.
- **База данных:** MySQL / MariaDB (возможен SQLite при смене URI).
- **Математика:** pandas, scipy.optimize для решения задачи минимизации.
- **Frontend:** Jinja2, HTML5, CSS3, JavaScript.
- **Нагрузка:** Locust (HttpUser-сценарии для HTML и API).

---

## Запуск проекта

### 1. Клонирование репозитория
```bash
git clone https://github.com/DoggerHou/ais_project.git
cd ais_project
```

### 2. Виртуальное окружение и зависимости
```bash
python -m venv .venv

# Windows:
.venv\Scripts\activate
# Linux/macOS:
# source .venv/bin/activate

pip install -r requirements.txt
```
### 3. Настройка БД
В app.py задана строка подключения:

```app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://user:password@localhost:3306/db_name'```
Перед запуском:  
1. Создайте БД в MySQL / MariaDB.  
2. Обновите логин, пароль и имя БД в URI.  
3. При первом запуске приложение создаст таблицы через SQLAlchemy.

При желании можно использовать SQLite, заменив URI, например, на:  
```app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///instance/project_db.sqlite'```


### 4. Запуск приложения
```python app.py```  

По умолчанию сервер доступен по адресу:  
`http://127.0.0.1:5000/`
